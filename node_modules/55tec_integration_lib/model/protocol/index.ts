
import { IdentifiablePromise, Registry } from "../../util/promise";
import { injectable } from "inversify";

export class Channel {

    send(data: any, ...args: any[]): any {
        console.log('CHANNEL | SEND | Data: ', data, ' | Args: ', ...args);
    }

    on(event: string, handler: (data: any, ...args: any[]) => any): any {
        console.log('CHANNEL | ON | Event: ', event, ' | Handler: ', handler);
    }

}

export interface Channel {

    send(req: any, ...args: any[]): any;
    on(event: string, handler: (res: any, ...args: any[]) => any): any;

}

export type Handler<Request = any, Response = any> = (data: Request | Response) => void;

/**
 * @TODO refine request default structure model
 */
export type Request = {
    id: string,
    [f: string]: any,
};

/**
 * @TODO refine response default structure model
 */
export type Response = {
    id: string,
    [f: string]: any,
};

export class ResolutionError extends Error {

    constructor(expectation: 'request' | 'response', data: Request | Response) {
        let found = 'request';
        if (expectation === 'request') found = 'response';

        super(`Invalid resolution: ${expectation} expected but ${found} found instead. Data: ${JSON.stringify(data)}`);
    }

}

/**
 * @TODO Implement generic types to stop resolving .send as any
 */
@injectable()
export abstract class Client {

    DEFAULT_REQUEST_TIMEOUT: number = 20000;

    protected readonly channel: Channel;
    protected readonly registry: Registry<Request, Response>;

    constructor(channel: Channel) {
        this.channel = channel;
        this.registry = {};

        this.channel.on('message', (data: any) => {
            if (!this.implementsProtocol(data)) return;
            return this.resolve(data);
        });
    }

    async send(...params: any[]): Promise<any> {

        let data = await this.build(...params);

        // to avoid overlappings
        if (!this.isRequest(data) && this.isResponse(data)) return this.channel.send(data);

        let promise = new IdentifiablePromise(data.id, data, this.registry);

        this.channel.send(data);

        if (this.DEFAULT_REQUEST_TIMEOUT > 0) promise.setTimeout(this.DEFAULT_REQUEST_TIMEOUT);

        return promise;
    }

    abstract implementsProtocol(target: any): target is Request | Response;

    abstract isRequest(target: any): target is Request;
    abstract isResponse(target: any): target is Response;

    protected abstract build(...params: any[]): Promise<Request | Response>;
    protected abstract handleUnregistredMessage(message: Request | Response): Promise<any>;

    /**
     * @TODO refactor -> this method is only necessary if requests are sent from client module. For protocols that handle requests and send responses, it has no use.
     */
    protected abstract parseResolution(data: Request | Response): any;

    protected resolve(data: Request | Response): void {
        let promise = this.registry[data.id];
        if (!promise) return this.handleUnregistredMessage(data) as any as void;

        try {
            return promise.resolve(this.parseResolution(data));
        } catch (err) {
            return promise.reject(err as Error);
        }
    }

}

export enum StatusCode {

    OK = "200",

    BAD_REQUEST = "400",
    UNAUTHORIZED = "401",
    FORBIDDEN = "403",
    NOT_FOUND = "404",
    CONFLICT = "409",
    GONE = "410",
    UNPROCESSABLE_ENTITY = "422",
    UNAVAILABLE_FOR_LEGAL_REASONS = "451",

    INTERNAL_ERROR = "500",
    SERVICE_UNAVAILABLE = "503",
    GATEWAY_TIMEOUT = "504",

}
