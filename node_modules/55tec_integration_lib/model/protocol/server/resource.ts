import { IdentifiablePromise } from "../../../util/promise";
import fs from 'fs'

export class HTTPError extends Error {

    code: string;
    name: string;

    constructor(message: string, code: string = '500', name: string = 'error') {
        super(message);
        this.code = code;
        this.name = name;
    }

    toJSON() {
        return {
            message: this.message,
            code: this.code,
            name: this.name,
        };
    }

    toString() {
        return `${this.code} - ${this.name} - ${this.message}`;
    }

}

export type Headers = {
    [h: string]: string | undefined
};

export enum Method {

    GET = 'get',
    POST = 'post',
    PUT = 'put',
    PATCH = 'patch',
    DELETE = 'delete',

}

export type SimpleRequest = {
    urn: string,
    method: Method,
    query: {[f: string]: any},
    body: any,
    params: {[f: string]: any},
    headers: {[f: string]: string},
    connection: {
        remoteAddress: string | undefined
    },
}

export interface Request extends SimpleRequest {
    header: (header: string) => string | undefined;
}

export interface Response {

    status(value: string | number): this;
    header(header: string, value: string): this;
    json(data: any, status?: string | number): void;
    end(): void;
    sendFile(path: string): void;
    text(data: string): void;
    send(data: string): void;

}

export type LiteralResponse = {
    code: string,
    headers?: Headers,
    body?: any,
};

export class RequestImpl implements Request {
    urn: string;
    method: Method;
    query: {[f: string]: any};
    body: {[f: string]: any};
    params: {[f: string]: any};
    headers: {[f: string]: string};
    connection: {
        remoteAddress: string | undefined
    };

    constructor(context: SimpleRequest) {
        this.urn = context.urn;
        this.method = context.method;
        this.query = context.query;
        this.body = context.body;
        this.params = context.params;
        this.headers = context.headers;
        this.connection = context.connection;
    }

    header(header: string) {
        return this.headers[header.toLowerCase()];
    };
}

export class ResponseImpl extends IdentifiablePromise<LiteralResponse, SimpleRequest> implements Response {

    code: string = '200';
    name?: string;
    body?: any;
    headers?: Headers;

    status(value: string | number): this {
        this.code = '' + value;
        return this;
    }

    json(data: any, status?: string | number): void {
        if (status) this.status(status);

        this.body = data;

        if ('2' !== this.code[0]) {
            let message = data;
            if (typeof message === 'object') message = data.message || data.error || data.reason || data.response || data.payload || JSON.stringify(data);

            return this.reject(new HTTPError(message, this.code, data.name));
        }

        this.resolve({
            code: this.code,
            body: this.body,
            headers: this.headers,
        });

    }

    end(): void {
        if ('2' !== this.code[0]) return this.reject(new HTTPError('', this.code, this.name));
        this.resolve({
            code: this.code,
            headers: this.headers,
        });
    }

    header(header: string, value: string): this {
        if (!this.headers) this.headers = {};
        this.headers[header.toLowerCase()] = value;
        return this;
    }

    sendFile(path: string) {
         fs.readFile(path, 'utf-8', (err, data) => {
             if (err) return this.reject(new HTTPError(err.message, '500'));
             if ('2' !== this.code[0]) return this.reject(new HTTPError(data, this.code, this.name));
             this.resolve({
                 code: this.code,
                 headers: {
                     ...(this.headers || {}),
                 },
                 body: data
             })
         })
    }

    text(content: string) {
        return this.send(content);
    }

    send(data: string) {
        if ('2' !== this.code[0]) return this.reject(new HTTPError(data, this.code, this.name));
        this.resolve({
            code: this.code,
            headers: { ...(this.headers || {}) },
            body: data,
        });
    }

}

enum StatusScheduling {
    FIRST = 'first',
    MIDDLE = 'middle',
    LAST = 'last',
}

export function* SchedulingStrategy(handlers: (Handler | Middleware)[]): Generator<{ status: StatusScheduling, handler: Handler | Middleware }, any, (Handler | Middleware)[]> {
    let i = 0;
    let status = StatusScheduling.FIRST;

    while (i < handlers.length) {
        const handler = handlers[i++];
        yield { handler, status };

        status = (i === handlers.length) ? StatusScheduling.LAST : StatusScheduling.MIDDLE;
    }
}

const routerMiddleware = (target: any, propertyName: string, descriptor: TypedPropertyDescriptor<(urn: string, ...args: Handler[]) => any>) => {
    const method = descriptor.value!;

    descriptor.value = function() {
        const [urn, ...handlers] = Object.values(arguments);

        const newArgument = async (req: Request, res: Response) => {
            const scheduling = SchedulingStrategy(handlers);

            // initializing
            let nextIterator = scheduling.next();

            while (!nextIterator.done) {
                const { value: { status, handler } } = nextIterator;

                if (status === StatusScheduling.LAST) return (handler as Handler)(req, res);

                let useNext = false;
                await handler(req, res, () => {
                    nextIterator = scheduling.next();
                    useNext = true;
                });

                if (!useNext) return;
            }
        }
        return method.call(this, urn, newArgument);
    };
};

export type Handler = (req: Request, res: Response) => void;
export type Middleware = (req: Request, res: Response, next: () => void) => any;

export type Registry = {
    [urn: string]: Handler
};

export class Router {

    readonly resources: {
        [method in Method]: Registry
    } = {
        [Method.GET]: {},
        [Method.POST]: {},
        [Method.PUT]: {},
        [Method.PATCH]: {},
        [Method.DELETE]: {},
    };

    @routerMiddleware
    get(urn: string, ...handlers: (Handler | Middleware)[]) {
        const [handler] = handlers as [Handler];
        return this.register(Method.GET, urn, handler);
    }

    @routerMiddleware
    post(urn: string, ...handlers: (Handler | Middleware)[]) {
        const [handler] = handlers;
        return this.register(Method.POST, urn, handler as unknown as Handler);
    }

    @routerMiddleware
    put(urn: string, ...handlers: (Handler | Middleware)[]) {
        const [handler] = handlers as [Handler];
        return this.register(Method.PUT, urn, handler);
    }

    @routerMiddleware
    patch(urn: string, ...handlers: (Handler | Middleware)[]) {
        const [handler] = handlers as [Handler];
        return this.register(Method.PATCH, urn, handler);
    }

    @routerMiddleware
    delete(urn: string, ...handlers: (Handler | Middleware)[]) {
        const [handler] = handlers as [Handler];
        return this.register(Method.DELETE, urn, handler);
    }

    register(method: Method, urn: string, handler: Handler) {
        this.resources[method][urn] = handler;
        return this;
    }

    getHandler(method: Method, urn: string): Handler | undefined {
        return this.resources[method][urn];
    }

}
