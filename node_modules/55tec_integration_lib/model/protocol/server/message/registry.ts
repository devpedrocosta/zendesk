
import { v4 as uuid } from 'uuid';
import { Request as _Request, Response as _Response, MessageType } from "../";
import { Method, Router } from "../resource";
import { Client as _Client, Channel } from '../../';
import {ResolutionError} from "../../index";

export type Request = _Request & {
    type: MessageType.REGISTRY,
    body: RequestBody,
};

export type RequestBody = {
    [method in Method]: string[] // urn[]
};

export type Response = _Response & {
    type: MessageType.REGISTRY,
};

export function isRequest(target: any): target is Request {

    return (
        !!target
        && (typeof target === 'object')
        && (typeof target.id === 'string')
        && (target.channel === 'server')
        && (target.type === MessageType.REGISTRY)
        && (target.body)
        && (typeof target.body === 'object')
        && (Object.keys(target.body).every(k => Object.values(Method).includes(k as Method)))
    );

}

export function isResponse(target: any): target is Response {

    return (
        !!target
        && (typeof target === 'object')
        && (typeof target.id === 'string')
        && (target.channel === 'server')
        && (target.type === MessageType.REGISTRY)
        && (!target.error || (typeof target.error === 'string'))
    );

}

export class Client extends _Client {

    constructor(channel: Channel) {
        super(channel);
    }

    async build(data: Router): Promise<Request> {

        return {
            id: uuid(),
            channel: 'server',
            type: MessageType.REGISTRY,
            body: Object.keys(data.resources).reduce((o: any, method: string) => {
                let registry = data.resources[method as Method];
                o[method] = Object.keys(registry);
                return o;
            }, {})
        };

    }

    async send(router: Router): Promise<any> {
        return super.send(router);
    }

    isRequest(target: any): target is Request { return isRequest(target); }

    isResponse(target: any): target is Response { return isResponse(target); }

    implementsProtocol(target: any): target is Request | Response {
        return this.isRequest(target) || this.isResponse(target);
    }

    protected async handleUnregistredMessage(message: Request | Response): Promise<any> {}

    protected parseResolution(data: Request | Response): any {
        if (!this.isResponse(data)) throw new ResolutionError('response', data);

        if (data.error) throw new Error(data.error);

        return {};
    }

}
