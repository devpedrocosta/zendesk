/**
 * @TODO refactor names
 */

import { Request as _Request, Response as _Response, MessageType } from "../";
import { Method, Router, SimpleRequest, RequestImpl as ResourceRequest, ResponseImpl as ResourceResponse, LiteralResponse as LiteralResourceResponse, Handler, HTTPError } from "../resource";
import { Client as _Client, Channel } from '../../';
import { Headers } from "../resource";

export type Request = _Request & {
    type: MessageType.ROUTE,
    body: RequestBody,
};

export type RequestBody = SimpleRequest;

export type Response = _Response & {
    type: MessageType.ROUTE,
    code: string,
    headers?: Headers,
    body?: ResponseBody,
    name?: string,
};

export type ResponseBody = any;

export function isRequest(target: any): target is SimpleRequest {

    return (
        !!target
        && (typeof target === 'object')
        && (typeof target.id === 'string')
        && (target.channel === 'server')
        && (target.type === MessageType.ROUTE)
        && (target.body && (typeof target.body === 'object'))
        && (typeof target.body.urn === 'string')
        && (Object.values(Method).includes(target.body.method))
        && (target.body.query && (typeof target.body.query === 'object'))
        && (target.body.body && (typeof target.body.body === 'object'))
        && (target.body.params && (typeof target.body.params === 'object'))
        && (target.body.headers && (typeof target.body.headers === 'object'))
    );

}

export function isResponse(target: any): target is Response {

    return (
        !!target
        && (typeof target === 'object')
        && (typeof target.id === 'string')
        && (target.channel === 'server')
        && (target.type === MessageType.ROUTE)
        && (!target.error || (typeof target.error === 'string'))
    );

}

export class Client extends _Client {

    REQUEST_HANDLER_TIMEOUT = 20000;

    routers: Router[] = [];

    constructor(channel: Channel) {
        super(channel);
    }

    add(router: Router) {
        this.routers.push(router);
    }

    async build(id: string, data: HTTPError | ResponseBody, code: string = '200', headers?: Headers): Promise<Response> {

        let res: Response = {
            id,
            channel: 'server',
            code,
            headers,
            type: MessageType.ROUTE,
        };

        if (data instanceof HTTPError) {
            res.error = data.message;
            res.code = data.code;
            res.name = data.name;
        } else res.body = data;

        return res;
    }

    async send(id: string, data: Error | ResponseBody, code?: string, headers?: Headers, name?: string): Promise<any> {
        return super.send(id, data, code, headers, name);
    }

    isRequest(target: any): target is Request { return isRequest(target); }

    isResponse(target: any): target is Response { return isResponse(target); }

    implementsProtocol(target: any): target is Request | Response {
        return this.isRequest(target) || this.isResponse(target);
    }

    protected async handleUnregistredMessage(message: Request | Response) {

        if (!this.isRequest(message)) return;

        let id = message.id;

        let {
            urn,
            method
        } = message.body;

        let router = this.routers.find(router => !!router.getHandler(method, urn));
        if (!router) return this.send(id, new HTTPError('Not found', '404'));

        let handler = router.getHandler(method, urn)!;

        try {
            let literal = await this.process(message, handler);
            return this.send(id, literal.body, literal.code, literal.headers);
        } catch (err:any) {
            if (!(err instanceof HTTPError)) err = new HTTPError(err.message);
            return this.send(id, err, err.code, {}, err.name);
        }

    }

    protected async process(req: Request, handler: Handler): Promise<LiteralResourceResponse> {
        let reqWrapper = new ResourceRequest(req.body);
        let resWrapper = new ResourceResponse(req.id, req.body);

        handler(reqWrapper, resWrapper);

        if (this.REQUEST_HANDLER_TIMEOUT > 0) resWrapper.setTimeout(this.REQUEST_HANDLER_TIMEOUT);

        return resWrapper;
    }

    protected parseResolution(data: Request | Response): any {
        // no resolution is needed if no requests are sent
    }

}
