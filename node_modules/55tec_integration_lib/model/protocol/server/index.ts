import { Channel, Client as _Client, Request as _Request, Response as _Response } from '../../protocol';
import { Router } from "./resource";

import { Client as RegistryClient, isRequest as isRegistryRequest, isResponse as isRegistryResponse } from './message/registry';
import { Client as RouteClient, isRequest as isRouteRequest, isResponse as isRouteResponse } from './message/route';

export type Request = _Request & {
    channel: 'server',
    type: string,
};

export type Response = _Response & {
    channel: 'server',
    error?: string,
};

export enum MessageType {
    REGISTRY = 'registry',
    ROUTE = 'route',
}

export function isRequest(target: any): target is Request {
    return isRegistryRequest(target) || isRouteRequest(target);
}

export function isResponse(target: any): target is Response {
    return isRegistryResponse(target) || isRouteResponse(target);
}

/**
 * @TODO refactor to make it respect liskov principle
 */
export class Client extends _Client {

    protected registryClient: RegistryClient;
    protected routeClient: RouteClient;

    constructor(channel: Channel) {
        super(channel);
        this.registryClient = new RegistryClient(channel);
        this.routeClient = new RouteClient(channel);
    }

    async use(router: Router) {
        await new Promise(resolve => setTimeout(resolve, 3000));
        await this.registryClient.send(router);
        this.routeClient.add(router);
    }

    async build(): Promise<Request | Response> {
        throw new Error('Method "build" cannot be called externally. Use "use" method instead');
    }

    async send(): Promise<any> {
        throw new Error('Method "send" cannot be called externally. Use "use" method instead');
    }

    isRequest(target: any): target is Request { return isRequest(target); }

    isResponse(target: any): target is Response { return isResponse(target); }

    implementsProtocol(target: any): target is Request | Response {
        return this.isRequest(target) || this.isResponse(target);
    }

    protected async handleUnregistredMessage(message: Request | Response): Promise<any> {}

    protected parseResolution(data: Request | Response) {}

    setTimeout(timeout: number) {
        this.routeClient.REQUEST_HANDLER_TIMEOUT = timeout;
    }

}

export { Router } from './resource';
