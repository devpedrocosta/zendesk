import { Origin } from './origin';
import { Credential } from '../credential';
import { Resource } from "../resource";

export type Pagination = {
    page: number,
    size: number,
    total?: number,
    nextPage?: number
};

/**
 * @property {string} current - current position
 * @property {number} limit - max amount of documents retrieved
 * @property {string} next - next position
 * @property {Object} sort - field used as index with sort order as value
 */
export type Cursor = {
    sort: { [field: string]: 1 | -1 },
    limit: number,
    current?: string, // new cursor
    next?: string,
};

export function getCursorQuery(identifier: string | undefined, sort: {[k: string]: 1 | -1}) {
    const fields = Object.keys(sort).sort();
    if (fields.length > 1) throw new Error('Cursors with multiple sort fields are not supported yet');
    if (!identifier) return {};
    const data = JSON.parse(Buffer.from(identifier, 'base64').toString('utf8'));
    return fields.reduce((o: any, e, i) => {
        let op: '$gt' | '$lt' = '$gt';
        if (sort[e] < 0) op = '$lt';
        o[e] = {[op]: data[i]};
        return o;
    }, {});
}

export function getNextCursor(dataSet: {[k: string]: any}[], cursor: Cursor): Cursor {
    const nCursor: Cursor = {
        sort: cursor.sort,
        limit: cursor.limit,
        next: undefined,
        current: cursor.next || cursor.current,
    };

    if (!dataSet.length) return nCursor;
    const last = dataSet[dataSet.length - 1];
    if (!last) return nCursor;

    const fields = Object.keys(cursor.sort).sort();
    if (fields.length > 1) throw new Error('Cursors with multiple sort fields are not supported yet');
    nCursor.next = Buffer.from(JSON.stringify(fields.map(k => {
        const segments = k.split('.');
        let target = last;
        for (const k of segments) {
            if (!target || typeof target !== 'object') return target;
            target = target[k];
        }
        if (target instanceof Date) return target.toISOString();
        return target;
    }))).toString('base64');

    return nCursor;
}

export type Options = {[field: string]: any};

export type Body = {
    data?: {[field: string]: any},
    credentials?: Credential[],
    pagination?: Pagination,
    cursor?: Cursor,
    projection?: Projection,
    options?: Options
};

export type BulkBody = Body & {
    data?: {[field: string]: any}[],
};

export class RequestError extends Error {

    code: string;

    constructor(message: string, code: number | string = '500') {
        super(message);
        this.code = '' + code;
    }

}

export type Projection = string[];

export type Request = {
    id: string,
    action: string,
    body?: Body,
    resources: Resource[],
    origin?: Origin,
    timeout?: number, // ms
}

export function isRequest(target: any): target is Request {

    return (
        !!target
        && (typeof target === 'object')
        && (typeof target.id === 'string')
        && (target.channel === undefined)
        && (target.action)
        && (typeof target.action === 'string')
        && (target.body === undefined || (target.body && (typeof target.body === 'object')))
        && (target.resources)
        && (typeof target.resources === 'object')
        && (target.resources.length !== undefined)
        && (target.origin === undefined || (
            target.origin
            && typeof target.origin === 'object'
            && typeof target.origin.id === 'string'
            && typeof target.origin.type === 'string'
        ))
        && (target.timeout === undefined || (
            ['string', 'number'].includes(typeof target.timeout)
            && !isNaN(+target.timeout)
        ))
    );

}
