/// <reference types="node" />
import Auth from "../../../util/auth";
import { Channel, Client as _Client, Request as _Request, Response as _Response } from '../../protocol';
import { Credential } from "../integrator/credential";
declare type ReadableStream = NodeJS.ReadableStream;
declare type WritableStream = NodeJS.WritableStream;
export declare enum Operation {
    DOWNLOAD = "download",
    UPLOAD = "upload"
}
export declare type RequestBody = {
    name: string;
    mimeType: string;
    repository: string;
    operation: Operation;
    credentials: Credential[];
    uri?: string;
    data?: string;
};
export declare type Request = _Request & {
    channel: 'file';
    body: RequestBody;
};
export declare type ResponseBody = File;
export declare type Response = _Response & {
    channel: 'file';
    error?: string;
    body?: ResponseBody;
};
export declare type File = {
    name: string;
    mimeType: string;
    repository: string;
    uri: string;
    createdAt?: string;
    size?: number;
    ttl?: number;
};
export declare function isRequest(target: any): target is Request;
export declare function isResponse(target: any): target is Response;
export declare type RequestArguments = Omit<RequestBody, 'data'> & {
    content?: ReadableStream;
};
/**
 * @TODO refactor to make it respect liskov principle
 */
export declare class Client extends _Client {
    private authUtils;
    constructor(channel: Channel, authUtils: Auth);
    downloadByStream(credentials: Credential[] | string, repository: string, filename: string, writable: WritableStream): Promise<void>;
    download(credentials: Credential[], repository: string, filename: string, destination: string): Promise<void>;
    uploadByStream(credentials: Credential[] | string, descriptorOrRepository: string | Omit<File, "uri">, readable: ReadableStream): Promise<File>;
    upload(credentials: Credential[], file: File): Promise<File>;
    build(): Promise<Request | Response>;
    send(): Promise<any>;
    isRequest(target: any): target is Request;
    isResponse(target: any): target is Response;
    implementsProtocol(target: any): target is Request | Response;
    protected handleUnregistredMessage(message: Request | Response): Promise<any>;
    protected parseResolution(data: Request | Response): void;
    private getFileBase;
    private getTokenAndSip;
}
export {};
