
import fs from "fs";
import qs from 'querystring';
import request from "request-promise";
import pbxConfig from 'config-pbx';

import Auth from "../../../util/auth";
import {Channel, Client as _Client, Request as _Request, Response as _Response} from '../../protocol';
import {Credential} from "../integrator/credential";


type ReadableStream = NodeJS.ReadableStream;
type WritableStream = NodeJS.WritableStream;

export enum Operation {
    DOWNLOAD = 'download',
    UPLOAD = 'upload'
}

export type RequestBody = {
    name: string,
    mimeType: string,
    repository: string,
    operation: Operation,
    credentials: Credential[],
    uri?: string
    data?: string, //base64
};

export type Request = _Request & {
    channel: 'file',
    body: RequestBody
};

export type ResponseBody = File;

export type Response = _Response & {
    channel: 'file',
    error?: string,
    body?: ResponseBody,
};

export type File = {
    name: string,
    mimeType: string,
    repository: string,
    uri: string,
    createdAt?: string,
    size?: number,
    ttl?: number,
};

export function isRequest(target: any): target is Request {

    return (
        !!target
        && (typeof target === 'object')
        && (typeof target.id === 'string')
        && (target.channel === 'file')
        && (target.body)
        && (typeof target.body === 'object')
        && (typeof target.body.name === 'string')
        && (typeof target.body.mimeType === 'string')
        && (typeof target.body.repository === 'string')
        && (typeof target.body.operation === 'string')
        && (typeof target.body.credentials === 'object')
        && (!target.body.uri || typeof target.body.uri === 'string')
        && (!target.body.data || typeof target.body.data === 'string')
    );

}

export function isResponse(target: any): target is Response {

    return (
        !!target
        && (typeof target === 'object')
        && (typeof target.id === 'string')
        && (target.channel === 'file')
        && (!target.error || (typeof target.error === 'string'))
        && (!target.body || (
            typeof target.body === 'object'
            && typeof target.body.name === 'string'
            && typeof target.body.mimeType === 'string'
            && typeof target.body.repository === 'string'
            && typeof target.body.createdAt === 'string'
            && typeof target.body.ttl === 'number'
            && (!target.body.uri || (typeof target.body.uri === 'string'))
            && (!target.body.data || (typeof target.body.data === 'string'))
        ))
    );

}
export type RequestArguments = Omit<RequestBody, 'data'> & {
    content?: ReadableStream, //base64
}

/**
 * @TODO refactor to make it respect liskov principle
 */
export class Client extends _Client {

    private authUtils: Auth;

    constructor(channel: Channel, authUtils: Auth) {
        super(channel);
        this.authUtils = authUtils;
    }

    async downloadByStream(credentials: Credential[] | string, repository: string, filename: string, writable: WritableStream) {
        const [token, sip] = await this.getTokenAndSip(credentials);

        const filesBase = await this.getFileBase(sip);
        const uri = `${filesBase}/${repository}/${filename}`;

        request.get(uri, {
            headers: {
                'authorization': `Bearer ${token}`
            },
        }).pipe(writable);
    }

    async download(credentials: Credential[], repository: string, filename: string, destination: string): Promise<void> {
        const file = fs.createWriteStream(destination);

        await this.downloadByStream(credentials, repository, filename, file);

        return new Promise((resolve, reject) => {
            file.on('finish', () => resolve());
            file.on('error', (err) => reject(err));
        });
    }

    async uploadByStream(credentials: Credential[] | string, descriptorOrRepository: string | Omit<File, "uri">, readable: ReadableStream): Promise<File> {
        const [token, sip] = await this.getTokenAndSip(credentials);

        let repository = descriptorOrRepository;
        let query = '';
        if (typeof descriptorOrRepository !== 'string') {
            repository = descriptorOrRepository.repository;
            query = '?' + qs.stringify(descriptorOrRepository)
        }

        const filesBase = await this.getFileBase(sip);
        let uri = `${filesBase}/${repository}${query}`;

        return new Promise((resolve, reject) => {
            request.post(uri, {
                headers: {
                    'authorization': `Bearer ${token}`,
                },
                formData: {
                    file: readable
                },
            }, (err, response) => {
                if (err) reject(err);

                resolve(JSON.parse(response.body));
            });

        });
    }

    async upload(credentials: Credential[], file: File): Promise<File> {
        const [token, sip] = await this.getTokenAndSip(credentials);

        const filesBase = await this.getFileBase(sip);
        const uri = `${filesBase}/${file.repository}`;

        return new Promise((resolve, reject) => {
            request.post(uri, {
                headers: {
                    'authorization': `Bearer ${token}`,
                    'content-type': 'application/json'
                },
                body: JSON.stringify({ file }),
            }, (err, response) => {
                if (err) reject(err);

                resolve(JSON.parse(response.body));
            });

        });
    }

    async build(): Promise<Request | Response> {
        throw new Error('Method "build" cannot be called externally. Use "upload", "download" or "download" method instead');
    }

    async send(): Promise<any> {
        throw new Error('Method "send" cannot be called externally. Use "upload", "download" or "download" method instead');
    }

    isRequest(target: any): target is Request { return isRequest(target); }

    isResponse(target: any): target is Response { return isResponse(target); }

    implementsProtocol(target: any): target is Request | Response {
        return this.isRequest(target) || this.isResponse(target);
    }

    protected async handleUnregistredMessage(message: Request | Response): Promise<any> {}

    protected parseResolution(data: Request | Response) {}

    private async getFileBase(sipServer: string) {
        let applications = pbxConfig.get('application-config', '' + process.env.NODE_ENV, { sipServer });

        if (applications && typeof applications.then === 'function') applications = await applications;
        const application = applications.find((e: any) => e.identifier === '55pbx');

        if (!application) throw new Error(`Application settings not found`);

        const sip = application.settings.sip.find((sip: any) => sip.sip_server === sipServer);

        if (!sip) throw new Error(`SIP settings not found: ${sipServer}`);

        return sip.files_base;
    }

    private async getTokenAndSip(credentials: Credential[] | string) {
        let search;

        if (typeof credentials === 'string') search = { clientId: credentials };
        else search = { credentials }

        const { clientId, sipServer } = await this.authUtils.getClient(search);

        const token = Auth.makeToken(clientId);

        return [ token, sipServer ];
    }
}
