
import fs from 'fs';
import path from 'path';
import { v4 as uuid } from "uuid";

import { ResolutionError } from "../";
import { Channel, Client as _Client, Request as _Request, Response as _Response } from '../../protocol';

export class CacheMissError extends Error {

    constructor(message: string) {
        super(`The function was not found on integrator cache - please send the full payload - ${message}`);
        Object.setPrototypeOf(this, CacheMissError.prototype);
    }

}

export type Request = _Request & {
    browserId: string,
    channel: 'browser',
    body: RequestBody
};

export type RequestBody = {
    name?: string,
    func?: string,
    params: any[],
    setup?: string
};

export type Response = _Response & {
    channel: 'browser',
    error?: string,
    body?: ResponseBody
};

export enum TargetType {
    ADMIN = 'admin',
    WEBPHONE = 'webphone',
    ALL = 'all',
}

export type Config = {
    target: TargetType | TargetType[],
}

export type ResponseBody = any;

export function isRequest(target: any): target is Request {

    return (
        !!target
        && (typeof target === 'object')
        && (typeof target.id === 'string')
        && (target.channel === 'browser')
        && (typeof target.browserId === 'string')
        && (target.body)
        && (typeof target.body === 'object')
        && (target.body.params)
        && (typeof target.body.params === 'object')
        && (target.body.params.length !== undefined)
        && (!target.body.setup || typeof target.body.setup === 'string')
        && (!target.body.func || typeof target.body.func === 'string')
        && (!target.body.name || typeof target.body.name === 'string')
    );

}

export function isResponse(target: any): target is Response {

    return (
        !!target
        && (typeof target === 'object')
        && (typeof target.id === 'string')
        && (target.channel === 'browser')
        && (!target.error || (typeof target.error === 'string'))
    );

}

export function generateBrowserId(clientId: string, branchNumber: string) {
    return `${clientId}-${branchNumber}`;
}

export class Client extends _Client {

    public readonly funcDir: string;
    protected readonly funcCache: { [file: string]: string };

    constructor(channel: Channel, funcDir: string) {
        super(channel);

        this.funcDir = funcDir;
        this.funcCache = {};
    }

    async load(funcName: string) {
        let func = await (
            new Promise<string>(
                (resolve, reject) =>
                    fs.readFile(
                        path.join(this.funcDir, `./${funcName}.js`),
                        (err, data) => err ? reject(err) : resolve(data.toString('ascii'))
                    )
            )
        );

        return this.funcCache[funcName] = func;
    }

    async build(browserId: string, funcName: string, data: any[]): Promise<Request> {
        const id = uuid();
        const body: RequestBody = {
            name: funcName,
            params: data,
        };

        if (!this.funcCache[funcName]) body.func = await this.load(funcName);
        if (funcName !== 'setup' && !this.funcCache['setup']) body.setup = await this.load('setup');

        return {
            id,
            browserId,
            channel: 'browser',
            body,
        };
    }

    async send(browserId: string, funcName: string, data: any[], config: Config = { target: TargetType.WEBPHONE }): Promise<any> {
        try {
            let result = await super.send(browserId, funcName, data, config);
            return result;
        } catch (err) {
            if (err instanceof CacheMissError) {
                delete this.funcCache[funcName];
                delete this.funcCache['setup'];
                return super.send(browserId, funcName, data, config);
            }
            throw err;
        }
    }

    isRequest(target: any): target is Request { return isRequest(target); }

    isResponse(target: any): target is Response { return isResponse(target); }

    implementsProtocol(target: any): target is Request | Response {
        return this.isRequest(target) || this.isResponse(target);
    }

    protected async handleUnregistredMessage(message: Request | Response): Promise<any> { }

    protected parseResolution(data: Request | Response) {
        if (!this.isResponse(data)) throw new ResolutionError('response', data);

        if (data.error) {
            if (data.error.toLowerCase().includes('cache miss')) throw new CacheMissError(data.error);
            throw new Error(data.error);
        }

        return data.body;
    }

}
