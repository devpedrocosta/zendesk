export type Registry<Response = any, Context = any> = {[id: string]: IdentifiablePromise<Response, Context>};

export class NamedError extends Error {

    name: string;

    constructor(message: string, name: string) {
        super(message);
        this.name = name;
        Object.setPrototypeOf(this, NamedError.prototype);
    }

    toJSON() {
        return {
            message: this.message,
            name: this.name,
        };
    }

}

export class Timeout {

    id?: NodeJS.Timeout;
    time: number;
    createdAt: Date;

    constructor(resolution: (...args: any[]) => any, time: number) {
        this.time = time;
        this.createdAt = new Date();

        if (time !== Infinity) this.id = setTimeout(() => {
            this.id = undefined;
            resolution();
        }, time);
    }

    stop() {
        if (this.id) clearTimeout(this.id);
    }

    timeLeft() {
        return Math.max(0, this.time - ((new Date()).getTime() - this.createdAt.getTime()));
    }

}

export class IdentifiablePromise<Response = any, Context = any> {

    static DEFAULT_RESOLUTION(req: IdentifiablePromise) {
        req.done = true;
        if (req.registry) delete req.registry[req.id];
        if (req.timeout) req.timeout.stop();
        return true;
    }

    readonly id: string;
    readonly context: Context;

    registry?: Registry;

    resolve: (res?: Response) => any;
    reject: (err: Error) => any;

    promise: Promise<any>;

    protected done: boolean;
    protected timeout?: Timeout;

    constructor(id: string, context: Context, registry?: Registry) {
        this.id = id;
        this.done = false;
        this.registry = registry;

        this.context = context;

        if (this.registry) this.registry[this.id] = this;

        this.resolve = (res?: Response) => IdentifiablePromise.DEFAULT_RESOLUTION(this);
        this.reject = (err: Error) => IdentifiablePromise.DEFAULT_RESOLUTION(this);

        this.promise = new Promise((resolve, reject) => {
            this.resolve = (res?: Response) => IdentifiablePromise.DEFAULT_RESOLUTION(this) && resolve(res);
            this.reject = (err: Error) => IdentifiablePromise.DEFAULT_RESOLUTION(this) && reject(err);
        });
    }

    then(onFulfilled: (...args: any[]) => any, onRejected?: (...args: any[]) => any) {
        return this.promise = this.promise.then(onFulfilled, onRejected);
    }

    catch(handler: (...args: any[]) => any) {
        return this.promise = this.promise.catch(handler);
    }

    finally(handler: (...args: any[]) => any) {
        return this.promise = this.promise.finally(handler);
    }

    isDone() {return this.done;}

    setTimeout(time: number) {
        this.timeout = new Timeout(() => {
            if(this.done) return;

            this.reject(new NamedError(`The request "${this.id}" timed out after ${time}ms`, 'message_timeout'));

        }, time);
    }

    untilTimeout() {
        if (!this.timeout) return Infinity;
        return this.timeout.timeLeft();
    }


    get [Symbol.toStringTag]() {
        return 'IdentifiablePromise';
    }

}
