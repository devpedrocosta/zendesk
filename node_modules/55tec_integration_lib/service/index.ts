import "reflect-metadata";
import { injectable } from "inversify";
import request from "request-promise";
import { URL } from "url";
import querystring from "querystring";

import {
    Options,
    Pagination,
    Projection,
    Request,
    RequestError,
} from "../model/protocol/integrator/request";

import {
    EmptyBody,
    FindBody as FindResponseBody,
    ListBody as ListResponseBody, ResponseError,
    SaveBody as SaveResponseBody
} from "../model/protocol/integrator/response";

import {
    Credential, DeviceCode, QRCode
} from "../model/protocol/integrator/credential";

import {
    Resource
} from "../model/protocol/integrator/resource";

import { Basic, Token, Type, Key, Session } from "../model/protocol/integrator/credential";
import { Entity } from "../model/metadata/action/entity";
import { Action } from "../model/metadata/action";
import { Origin } from "../model/protocol/integrator/request/origin";
import {StatusCode} from "../model/protocol";
import {Cursor} from "../model/protocol/integrator/request/index";

@injectable()
export default class Service {

    static DEFAULT_PAGE_SIZE = 100;

    async request(url: string, method: "get" | "post" | "put" | "patch", body?: object, headers: object = {}, secure = true) {

        if (body && method === "get") {
            let parsed = new URL(url);
            body = {
                ...querystring.parse(parsed.search),
                ...body
            };

            url = `${parsed.origin}${parsed.pathname}?${querystring.stringify(body as any)}${parsed.hash}`;
        }

        headers = {
            'Content-Type': 'application/json',
            ...headers
        };

        let result = await request({
            "rejectUnauthorized": secure,
            "url": url,
            "method": method,
            "body": method !== "get" ? JSON.stringify(body) : undefined,
            "headers": headers,
            "simple": false,
            "resolveWithFullResponse": true
        });

        if (("" + result.statusCode)[0] !== "2") throw new RequestError(result.body, result.statusCode);
        if (!result.body) return {};

        let data = result.body;
        if (typeof data === "string") data = JSON.parse(result.body.trim() || "{}");

        return data;
    }

    async save(ctx: Context): Promise<SaveResponseBody> {
        throw new ResponseError(`Not implemented yet`, StatusCode.SERVICE_UNAVAILABLE);
    }

    async find(ctx: Context): Promise<FindResponseBody> {
        throw new ResponseError(`Not implemented yet`, StatusCode.SERVICE_UNAVAILABLE);
    }

    async list(ctx: Context): Promise<ListResponseBody> {
        throw new ResponseError(`Not implemented yet`, StatusCode.SERVICE_UNAVAILABLE);
    }

    async delete(ctx: Context): Promise<EmptyBody> {
        throw new ResponseError(`Not implemented yet`, StatusCode.SERVICE_UNAVAILABLE);
    }

    getWWWURL(entity: Entity, id: string, ctx?: Context): string {
        throw new ResponseError(`Not implemented yet`, StatusCode.SERVICE_UNAVAILABLE);
    }

}

export class Context<O extends Options = Options> {

    id: string;

    action: Action;

    auth: {
        [Type.BASIC]?: Basic,
        [Type.TOKEN]?: Token,
        [Type.KEY]?: Key,
        [Type.SESSION]?: Session,
        [Type.DEVICE_CODE]?: DeviceCode
        [Type.QRCODE]?: QRCode
    } = {};

    credentials: Credential[];

    payload: {[f: string]: any};

    opts: O;

    params: {
        projection: Projection,
        cursor?: Cursor,
        pagination: Pagination
    };

    resourceMap: {
        [type: string]: Resource
    };

    origin?: Origin;

    timeout?: number;

    constructor(req: Request) {

        this.id = req.id;

        if (!req.body) throw new RequestError(`Missing request body: ${JSON.stringify({ ...req, "credentials": undefined })}`, "400");

        this.action = req.action;

        let {
            credentials = [],
            projection = [],
            data = {},
            pagination = {
                "page": 0,
                "size": Service.DEFAULT_PAGE_SIZE
            },
            cursor,
            options = {}
        } = req.body;

        this.credentials = credentials;
        for (let c of credentials) { // @ts-ignore
            this.auth[c.type] = c.value as any;
        }
        this.payload = data;
        this.opts = options as O;
        // if (!cursor) cursor = { limit: pagination.size, current: pagination.page };
        this.params = { projection, pagination, cursor };
        this.resourceMap = (req.resources || []).reduce((map: any, e: Resource) => {
            map[e.type] = e;
            return map;
        }, {});
        this.origin = req.origin;
        this.timeout = req.timeout;
    }

    getAuthHeader() {
        // if (this.auth[Type.KEY]) return {'Authorization': `Bearer ${this.auth[Type.KEY]}`};
        if (this.auth[Type.TOKEN]) return {'Authorization': `Bearer ${this.auth[Type.TOKEN]}`};
        if (this.auth[Type.BASIC]) {
            let {
                id,
                secret
            } = this.auth[Type.BASIC]!;

            return {'Authorization': `Basic ${Buffer.from(`${id}:${secret}`).toString("base64")}`};
        }

        return {};
    }

    hasResource(type: string) {
        return !!this.resourceMap[type];
    }

}
